{"ast":null,"code":"var CombinedStream = require('combined-stream');\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar parseUrl = require('url').parse;\n\nvar fs = require('fs');\n\nvar mime = require('mime-types');\n\nvar async = require('async');\n\nmodule.exports = FormData;\n\nfunction FormData() {\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n  CombinedStream.call(this);\n}\n\nutil.inherits(FormData, CombinedStream);\nFormData.LINE_BREAK = '\\r\\n';\n\nFormData.prototype.append = function (field, value, options) {\n  options = options || {};\n  var append = CombinedStream.prototype.append.bind(this); // all that streamy business can't handle numbers\n\n  if (typeof value == 'number') value = '' + value; // https://github.com/felixge/node-form-data/issues/38\n\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n\n  var footer = this._multiPartFooter(field, value, options);\n\n  append(header);\n  append(value);\n  append(footer); // pass along options.knownLength\n\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function (header, value, options) {\n  var valueLength = 0; // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength; // @check why add CRLF? does this account for custom/multiple CRLFs?\n\n  this._overheadLength += Buffer.byteLength(header) + +FormData.LINE_BREAK.length; // empty or either doesn't have path or not an http response\n\n  if (!value || !value.path && !(value.readable && value.hasOwnProperty('httpVersion'))) {\n    return;\n  } // no need to bother with the length\n\n\n  if (!options.knownLength) this._lengthRetrievers.push(function (next) {\n    if (value.hasOwnProperty('fd')) {\n      // take read range into a account\n      // `end` = Infinity –> read file till the end\n      //\n      // TODO: Looks like there is bug in Node fs.createReadStream\n      // it doesn't respect `end` options without `start` options\n      // Fix it when node fixes it.\n      // https://github.com/joyent/node/issues/7819\n      if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n        // when end specified\n        // no need to calculate range\n        // inclusive, starts with 0\n        next(null, value.end + 1 - (value.start ? value.start : 0)); // not that fast snoopy\n      } else {\n        // still need to fetch file size from fs\n        fs.stat(value.path, function (err, stat) {\n          var fileSize;\n\n          if (err) {\n            next(err);\n            return;\n          } // update final size based on the range options\n\n\n          fileSize = stat.size - (value.start ? value.start : 0);\n          next(null, fileSize);\n        });\n      } // or http response\n\n    } else if (value.hasOwnProperty('httpVersion')) {\n      next(null, +value.headers['content-length']); // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty('httpModule')) {\n      // wait till response come back\n      value.on('response', function (response) {\n        value.pause();\n        next(null, +response.headers['content-length']);\n      });\n      value.resume(); // something else\n    } else {\n      next('Unknown stream');\n    }\n  });\n};\n\nFormData.prototype._multiPartHeader = function (field, value, options) {\n  var boundary = this.getBoundary();\n  var header = ''; // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n\n  if (options.header != null) {\n    header = options.header;\n  } else {\n    header += '--' + boundary + FormData.LINE_BREAK + 'Content-Disposition: form-data; name=\"' + field + '\"'; // fs- and request- streams have path property\n    // or use custom filename and/or contentType\n    // TODO: Use request's response mime-type\n\n    if (options.filename || value.path) {\n      header += '; filename=\"' + path.basename(options.filename || value.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + (options.contentType || mime.lookup(options.filename || value.path)); // http response has not\n    } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n      header += '; filename=\"' + path.basename(value.client._httpMessage.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + value.headers['content-type'];\n    }\n\n    header += FormData.LINE_BREAK + FormData.LINE_BREAK;\n  }\n\n  return header;\n};\n\nFormData.prototype._multiPartFooter = function (field, value, options) {\n  return function (next) {\n    var footer = FormData.LINE_BREAK;\n    var lastPart = this._streams.length === 0;\n\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function () {\n  return '--' + this.getBoundary() + '--';\n};\n\nFormData.prototype.getHeaders = function (userHeaders) {\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (var header in userHeaders) {\n    formHeaders[header.toLowerCase()] = userHeaders[header];\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getCustomHeaders = function (contentType) {\n  contentType = contentType ? contentType : 'multipart/form-data';\n  var formHeaders = {\n    'content-type': contentType + '; boundary=' + this.getBoundary(),\n    'content-length': this.getLengthSync()\n  };\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function () {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function () {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n}; // Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\n\n\nFormData.prototype.getLengthSync = function (debug) {\n  var knownLength = this._overheadLength + this._valueLength; // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  } // https://github.com/felixge/node-form-data/issues/40\n\n\n  if (this._lengthRetrievers.length) {\n    // Some async length retrivers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function (cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function (err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function (length) {\n      knownLength += length;\n    });\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function (params, cb) {\n  var request,\n      options,\n      defaults = {\n    method: 'post'\n  }; // parse provided url if it's string\n  // or treat it as options object\n\n  if (typeof params == 'string') {\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname\n    }, defaults);\n  } else // use custom params\n    {\n      options = populate(params, defaults); // if no port provided use default one\n\n      if (!options.port) {\n        options.port = options.protocol == 'https:' ? 443 : 80;\n      }\n    } // put that good code in getHeaders to some use\n\n\n  options.headers = this.getHeaders(params.headers); // https if specified, fallback to http in any other case\n\n  if (params.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  } // get content length and fire away\n\n\n  this.getLength(function (err, length) {\n    // TODO: Add chunked encoding when no length (if err)\n    // add content length\n    request.setHeader('Content-Length', length);\n    this.pipe(request);\n\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n  return request;\n};\n\nFormData.prototype._error = function (err) {\n  if (this.error) return;\n  this.error = err;\n  this.pause();\n  this.emit('error', err);\n};\n/*\n * Santa's little helpers\n */\n// populates missing values\n\n\nfunction populate(dst, src) {\n  for (var prop in src) {\n    if (!dst[prop]) dst[prop] = src[prop];\n  }\n\n  return dst;\n}","map":{"version":3,"sources":["C:/Users/porti/Desktop/quote-machine/node_modules/unirest/node_modules/form-data/lib/form_data.js"],"names":["CombinedStream","require","util","path","http","https","parseUrl","parse","fs","mime","async","module","exports","FormData","_overheadLength","_valueLength","_lengthRetrievers","call","inherits","LINE_BREAK","prototype","append","field","value","options","bind","isArray","_error","Error","header","_multiPartHeader","footer","_multiPartFooter","_trackLength","valueLength","knownLength","Buffer","isBuffer","length","byteLength","readable","hasOwnProperty","push","next","end","undefined","Infinity","start","stat","err","fileSize","size","headers","on","response","pause","resume","boundary","getBoundary","filename","basename","contentType","lookup","client","_httpMessage","lastPart","_streams","_lastBoundary","getHeaders","userHeaders","formHeaders","toLowerCase","getCustomHeaders","getLengthSync","_boundary","_generateBoundary","i","Math","floor","random","toString","debug","getLength","cb","process","nextTick","parallel","values","forEach","submit","params","request","defaults","method","populate","port","pathname","host","hostname","protocol","setHeader","pipe","error","emit","dst","src","prop"],"mappings":"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","sourcesContent":["var CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar mime = require('mime-types');\nvar async = require('async');\n\nmodule.exports = FormData;\nfunction FormData() {\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n\n  CombinedStream.call(this);\n}\nutil.inherits(FormData, CombinedStream);\n\nFormData.LINE_BREAK = '\\r\\n';\n\nFormData.prototype.append = function(field, value, options) {\n  options = options || {};\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') value = ''+value;\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter(field, value, options);\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    + FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength)\n  this._lengthRetrievers.push(function(next) {\n\n    if (value.hasOwnProperty('fd')) {\n\n      // take read range into a account\n      // `end` = Infinity –> read file till the end\n      //\n      // TODO: Looks like there is bug in Node fs.createReadStream\n      // it doesn't respect `end` options without `start` options\n      // Fix it when node fixes it.\n      // https://github.com/joyent/node/issues/7819\n      if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n        // when end specified\n        // no need to calculate range\n        // inclusive, starts with 0\n        next(null, value.end+1 - (value.start ? value.start : 0));\n\n      // not that fast snoopy\n      } else {\n        // still need to fetch file size from fs\n        fs.stat(value.path, function(err, stat) {\n\n          var fileSize;\n\n          if (err) {\n            next(err);\n            return;\n          }\n\n          // update final size based on the range options\n          fileSize = stat.size - (value.start ? value.start : 0);\n          next(null, fileSize);\n        });\n      }\n\n    // or http response\n    } else if (value.hasOwnProperty('httpVersion')) {\n      next(null, +value.headers['content-length']);\n\n    // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty('httpModule')) {\n      // wait till response come back\n      value.on('response', function(response) {\n        value.pause();\n        next(null, +response.headers['content-length']);\n      });\n      value.resume();\n\n    // something else\n    } else {\n      next('Unknown stream');\n    }\n  });\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  var boundary = this.getBoundary();\n  var header = '';\n\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (options.header != null) {\n    header = options.header;\n  } else {\n    header += '--' + boundary + FormData.LINE_BREAK +\n      'Content-Disposition: form-data; name=\"' + field + '\"';\n\n    // fs- and request- streams have path property\n    // or use custom filename and/or contentType\n    // TODO: Use request's response mime-type\n    if (options.filename || value.path) {\n      header +=\n        '; filename=\"' + path.basename(options.filename || value.path) + '\"' + FormData.LINE_BREAK +\n        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));\n\n    // http response has not\n    } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n      header +=\n        '; filename=\"' + path.basename(value.client._httpMessage.path) + '\"' + FormData.LINE_BREAK +\n        'Content-Type: ' + value.headers['content-type'];\n    }\n\n    header += FormData.LINE_BREAK + FormData.LINE_BREAK;\n  }\n\n  return header;\n};\n\nFormData.prototype._multiPartFooter = function(field, value, options) {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--';\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (var header in userHeaders) {\n    formHeaders[header.toLowerCase()] = userHeaders[header];\n  }\n\n  return formHeaders;\n}\n\nFormData.prototype.getCustomHeaders = function(contentType) {\n    contentType = contentType ? contentType : 'multipart/form-data';\n\n    var formHeaders = {\n        'content-type': contentType + '; boundary=' + this.getBoundary(),\n        'content-length': this.getLengthSync()\n    };\n\n    return formHeaders;\n}\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function(debug) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/40\n  if (this._lengthRetrievers.length) {\n    // Some async length retrivers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n\n  var request\n    , options\n    , defaults = {\n        method : 'post'\n    };\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n    params = parseUrl(params);\n\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname\n    }, defaults);\n  }\n  else // use custom params\n  {\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (params.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n\n    // TODO: Add chunked encoding when no length (if err)\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (this.error) return;\n\n  this.error = err;\n  this.pause();\n  this.emit('error', err);\n};\n\n/*\n * Santa's little helpers\n */\n\n// populates missing values\nfunction populate(dst, src) {\n  for (var prop in src) {\n    if (!dst[prop]) dst[prop] = src[prop];\n  }\n  return dst;\n}\n"]},"metadata":{},"sourceType":"script"}